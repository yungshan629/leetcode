class Solution:
    def jump(self, nums: List[int]) -> int:
        move = 0
        n = len(nums)
        if n == 1:
            return 0


        i = 0
        while i + nums[i] < n-1:
            list1 = nums[i+1:i+nums[i]+1]
            list2 = list(range(len(list1)))
            step_list = [a+b for a, b in zip(list1, list2)]
            if len(set(step_list)) == 1:
                step = nums[i]
            else:
                step = step_list.index(max(step_list))+ 1
   

            i += step
            move += 1
        

        return move + 1


雖然是寫出來了，但寫的不夠精簡，步驟太多、太複雜了，
我是每一輪迴圈去處理之後要走的路徑，
不過其實可以在迴圈外就先處理，這樣就不會要一直重覆計算了


class Solution:
    def jump(self, nums: List[int]) -> int:

        x = [nums[i]+i for i in range(len(nums))]  
        # each element in this represent max index that can be reached from the current index 

        l,r,jumps = 0,0,0

        while r < len(nums)-1 :
            jumps += 1
            l,r = r+1,max(x[l:r+1]) 

        return jumps


[5,9,3,2,1,0,2,3,3,1,0,0]
[0,1,2,3,4,5,6,7,8,9,10,11]
在9 的時候，如果加上 index
[0,0,5,5,5,5,7,10,11,10,10,11]

如果有2個重覆，要選後一個
其實應該把可以走的步數加上他的index，這樣才能知道那個是能走最遠的
但如果加上index, 會不會出現能走0步的變成最大步？好像不會？


1. 買的時候不一定是最小值，賣的時候也不一定是最大值
2. 寫迴圈，逐i記算，找i以後的最大值賣出，記錄利潤
3. 從profit set中，找利潤最大值
4. 遞減的序列在一開始就可以考慮排除
5. profit set 應該不會有負值
