## Problem

https://leetcode.com/problems/minimum-array-end

## Problem Description

You are given two integers n and x. You have to construct an array of **positive** integers `nums` of size `n` 
where for every `0 <= i < n - 1`, `nums[i + 1]` is **greater tha**n `nums[i]`, and the result of the bitwise `AND` operation between 
all elements of `nums` is `x`.

Return the **minimum** possible value of `nums[n - 1]`.

**Example 1:**

**Input:** n = 3, x = 4  <br>
**Output:** 6  <br>
**Explanation:**    <br>
`nums` can be `[4,5,6]` and its last element is 6.

**Example 2:**

**Input:** n = 2, x = 7  <br>
**Output:** 15  <br>
**Explanation:**  <br>
`nums` can be `[7,15]` and its last element is 15.

## Approach
這是我第三次做位元運算的題目，感覺自己像是原始人一樣，連火都還不會升，就要想怎麼造火箭了。先提供必要的工具：
* x & (1 << N) 檢查第 N 位是否為 1
* x | (1 << N) 將第 N 位設成 1
首先把研究例題，把 x 轉換成二進位後列出來，並依序尋找，要怎樣才能達成達件

1. 先搜尋 x 有那些位元是 0，並紀錄位置。
2. 將 (n - 1) 轉換為二進位，依序將 x 位元是 0 的部分，填入 (n - 1)的二進位的碼。
3. 一開始是用 list 跟 pop() 的方式實現，爾後是改成位元運算的方式實現。



## Code

- Support Language: Java, Python

Python Code:

```py
class Solution:
    def minEnd(self, n: int, x: int) -> int:
        digitlist=[]
        n_digit = [int(bit) for bit in bin(n-1)[2:]]

        for i in range(64):
            if x & (1 << i) == 0:
                digitlist.append(i)
        
        for j in digitlist:
            if not n_digit:
                break
            k = n_digit.pop()
            x = x| (k << j)

        return x
```

```py
class Solution:
    def minEnd(self, n: int, x: int) -> int:
        n = n - 1
        n1 =len(bin(x))+len(bin(n))

        for i in range(n1):
            if x & (1 << i) == 0:
                if n & 1 != 0:
                    x = x| (1 << i)
                n = n >> 1

        return x
```

Java Code:

```java
class Solution {
    public long minEnd(int n, int x) {
        long n1 = n - 1;
        long x1 = x;       
        for(int i = 0; i < 64; i++) {
            if((x1 & (1L << i)) == 0) {
                if((n1 & 1) != 0) {
                    x1 = x1 | (1L << i);
                }
                n1 = n1 >> 1;
            }
        }       
        return x1;
    }
}
```

**_Complexity Anlysis_**

- _Time Complexity_: 
- _Space Complexity_：
