## Problem

https://leetcode.com/problems/next-permutation/

## Problem Description

A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.

- For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.

The **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

- For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.
- Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.
- While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.

Given an array of integers `nums`, find the next permutation of `nums`.

The replacement must be *in place* and use only constant extra memory.

 
**Example 1:**

Input: nums = [1,2,3]  <br>
Output: [1,3,2]


## Approach
這題需要多列出一些組合，仔細觀察數字的變化。
1. 從右往左找,直到發現第一個破壞下降順序的數字(i)，這個位置是改變的起點
2. 從最右邊找到最小的大於(i)的數字，將這兩個數字交換
3. 由於(i)之後的所有數字必定是降序排列，故將這些數字反轉，不需要用排序(sorted)

<br>

1. From right to left, find the first number that breaks the descending order (i), this position is the starting point for change
2. From the rightmost position, find the smallest number that is greater than (i), and swap these two numbers
3. Since all numbers after (i) must be in descending order, reverse these numbers instead of using sorted()

## Code

- Support Language: Java, Python

Python Code:

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        i = n - 2
        while i >= 0 and nums[i] >= nums[i+1]:
            i -= 1
        if i >= 0:
            j = n - 1
            while nums[j] <= nums[i]:
                j -= 1

            nums[i], nums[j] = nums[j], nums[i]        
        nums[i+1:] = reversed(nums[i+1:])
```

Java Code:

```

```

**_Complexity Anlysis_**

- _Time Complexity_: 
- _Space Complexity_：
