## Problem

https://leetcode.com/problems/pancake-sorting/description/

## Problem Description

Given an array of integers arr, sort the array by performing a series of **pancake flips.**

In one pancake flip we do the following steps:

- Choose an integer `k` where `1 <= k <= arr.length.`
- Reverse the sub-array `arr[0...k-1]` **(0-indexed).**

For example, if `arr = [3,2,1,4]` and we performed a pancake flip choosing `k = 3`, we reverse the sub-array `[3,2,1]`, so `arr = [1,2,3,4]` after the pancake flip at `k = 3`.

*Return an array of the* `k`-*values corresponding to a sequence of pancake flips that sort* `arr`. Any valid answer that sorts the array within `10 * arr.length` flips will be judged as correct.

 
**Example 1:**

**Input:** arr = [3,2,4,1]  <br>
**Output:** [4,2,4,3]  <br>
**Explanation:**   <br>
We perform 4 pancake flips, with k values 4, 2, 4, and 3.  <br>
Starting state: arr = [3, 2, 4, 1]  <br>
After 1st flip (k = 4): arr = [1, 4, 2, 3]  <br>
After 2nd flip (k = 2): arr = [4, 1, 2, 3]  <br>
After 3rd flip (k = 4): arr = [3, 2, 1, 4]  <br>
After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.



## Approach

## Code

- Support Language: Java, Python

Python Code:

```py
class Solution:
    def pancakeSort(self, arr: List[int]) -> List[int]:
        if arr == sorted(arr):
            return []
        
        output = []
        n = len(arr)
        for i in range(n,0,-1):
            k = arr.index(i) + 1 
            if k == i:
                continue
            else:
                arr[0:k] = list(reversed(arr[0:k]))
                output.append(k)
            
            if i == 1:
                break
            else:
                arr[0:k+1] = list(reversed(arr[0:k+1]))
                output.append(k+1)

        print(arr)

        return output
        
```

Java Code:

```

```

**_Complexity Anlysis_**

- _Time Complexity_: 
- _Space Complexity_ï¼š
