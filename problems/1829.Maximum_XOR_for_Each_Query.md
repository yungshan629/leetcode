## Problem

https://leetcode.com/problems/maximum-xor-for-each-query/

## Problem Description

You are given a **sorted** array `nums` of `n` non-negative integers and an integer `maximumBit`. You want to perform the following query `n` **times**:

1. Find a non-negative integer k < $2^{maximumBit}$ such that `nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k` is **maximized**. `k` is the answer to the $i^{th}$ query.
2. Remove the **last** element from the current array `nums`.
   
Return *an array `answer`, where `answer[i]` is the answer to the* $i^{th}$ query.

**Example 1:**

**Input:** nums = [0,1,1,3], maximumBit = 2  <br>
**Output:** [0,3,2,3]  <br>
**Explanation:** The queries are answered as follows:  <br>
1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.  <br>
2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.  <br>
3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.  <br>
4th query: nums = [0], k = 3 since 0 XOR 3 = 3.



## Approach

## Code

- Support Language: Java, Python

Python Code:

```py
class Solution:
    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
        target = 2**maximumBit - 1
        curr = 0
        output = []

        for i in range(len(nums)):
            curr = curr ^ nums[i]
            output.append(target - curr)    # output.append(target ^ curr)

        output.reverse()
        
        return output
```

Java Code:

```

```

**_Complexity Anlysis_**

- _Time Complexity_: 
- _Space Complexity_ï¼š
