## Problem

https://leetcode.com/problems/prime-in-diagonal/

## Problem Description

```
You are given a 0-indexed two-dimensional integer array nums.

Return the largest prime number that lies on at least one of the diagonals of nums. In case, no prime
is present on any of the diagonals, return 0.

Note that:

An integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and
itself. An integer val is on one of the diagonals of nums if there exists an integer i for which
nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.

1   2   3
4   5   6
7   8   9

In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].

Example 1:

Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
Output: 11
Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the
diagonals. Since 11 is the largest prime, we return 11.
```

## Approach
算是一道簡單的題目，只要迴圈收集對角線的數字，再從最大數開始排除質數即可。

和先前找因數的題目一樣，在確認有沒有因數時，只要確認到 $/sqrt(x)$ 就足夠。
## Code

- Support Language: Java,Python

Python Code:

```py
class Solution:
    def diagonalPrime(self, nums: List[List[int]]) -> int:
        n = len(nums)
        list=[]
        for i in range(n):
            list.append(nums[i][i])
            list.append(nums[i][n-i-1])
        
        list.sort(reverse=True)

        for i in range(len(list)):
            if list[i] == 2:
                return 2
            for j in range(2,int(list[i]**0.5)+1):
                if list[i] % j == 0: 
                    break
                elif j == int(list[i]**0.5):
                    return list[i]
        return 0
```

Java Code:

```

```

**_Complexity Anlysis_**

- _Time Complexity_: 
- _Space Complexity_：
